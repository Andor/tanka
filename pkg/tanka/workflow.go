package tanka

import (
	"fmt"
	"os"
	"strings"

	"github.com/pkg/errors"

	"github.com/grafana/tanka/pkg/kubernetes"
	"github.com/grafana/tanka/pkg/kubernetes/manifest"
)

// Label applied to all resources. Used to identify resources that are eligible for
// deletion, if not present in the generated set of manifests.
const tankaEnvironmentLabel = "tanka/environment"

// Apply parses the environment at the given directory (a `baseDir`) and applies
// the evaluated jsonnet to the Kubernetes cluster defined in the environments
// `spec.json`.
// NOTE: This function prints on screen in default configuration.
// Use the `WithWarnWriter` modifier to change that. The `WithApply*` modifiers
// may be used to further influence the behavior.
func Apply(baseDir string, mods ...Modifier) error {
	opts := parseModifiers(mods)

	p, err := parse(baseDir, opts)
	if err != nil {
		return err
	}

	p = applyTankaLabels(p, baseDir)

	kube, err := p.newKube()
	if err != nil {
		return err
	}

	diff, err := kube.Diff(p.Resources, kubernetes.DiffOpts{})
	if err != nil {
		return errors.Wrap(err, "diffing")
	}
	if diff == nil {
		tmp := "Warning: There are no differences. Your apply may not do anything at all."
		diff = &tmp
	}

	if opts.wWarn == nil {
		opts.wWarn = os.Stderr
	}
	fmt.Fprintln(opts.wWarn, *diff)

	return kube.Apply(p.Resources, opts.apply)
}

// Diff parses the environment at the given directory (a `baseDir`) and returns
// the differences from the live cluster state in `diff(1)` format. If the
// `WithDiffSummarize` modifier is used, a histogram created using `diffstat(1)`
// is returned instead.
// The cluster information is retrieved from the environments `spec.json`.
// NOTE: This function requires on `diff(1)`, `kubectl(1)` and perhaps `diffstat(1)`
func Diff(baseDir string, mods ...Modifier) (*string, error) {
	opts := parseModifiers(mods)

	p, err := parse(baseDir, opts)
	if err != nil {
		return nil, err
	}
	p = applyTankaLabels(p, baseDir)

	kube, err := p.newKube()
	if err != nil {
		return nil, err
	}

	changes, err := kube.Diff(p.Resources, opts.diff)
	if err != nil {
		return nil, err
	}
	if !opts.applyDeletes {
		return changes, nil
	}
	deletions, err := reconcileDeletions(p, baseDir)
	if len(deletions) == 0 {
		return changes, nil
	}
	output := "--- resources that will be deleted:"
	for _, deletion := range deletions {
		output += "\n- " + deletion
	}
	if changes != nil {
		output += *changes
	}
	return &output, nil
}

// Show parses the environment at the given directory (a `baseDir`) and returns
// the evaluated jsonnet in yaml form
func Show(baseDir string, mods ...Modifier) (string, error) {
	opts := parseModifiers(mods)

	p, err := parse(baseDir, opts)
	if err != nil {
		return "", err
	}

	p = applyTankaLabels(p, baseDir)

	return p.Resources.String(), nil
}

func applyTankaLabels(p *ParseResult, environment string) *ParseResult {
	for _, m := range p.Resources {
		labels := m.Metadata().Labels()
		labels[tankaEnvironmentLabel] = getEnvironmentLabel(environment)
		m.Metadata().SetLabels(labels)
	}
	return p
}

// These resource types are autogenerated, and propogate our labels, so we must ignore
// them when identifying which resources to delete
var resourceTypesToIgnore = map[string]bool{"componentstatuses": true, "endpoints": true}

// reconcileDeletions compares generated manifests with labelled resources in Kubernetes
// and identifies resources in Kubernetes not mentioned in manifests: i.e. candidates for
// deletion.
func reconcileDeletions(p *ParseResult, environment string) ([]string, error) {

	environmentLabel := getEnvironmentLabel(environment)

	kube, err := p.newKube()
	if err != nil {
		return nil, err
	}
	apiResourcesOpts := kubernetes.APIResourcesOpts{Output: "name", Verbs: []string{"list"}}
	apiResources, err := kube.APIResources(apiResourcesOpts)
	if err != nil {
		return nil, err
	}

	stateMap := map[string]bool{}
	namespaces := map[string]bool{}
	for _, resource := range p.Resources {
		namespace := resource.Metadata().Namespace()
		resourceCode := getResourceCode(namespace, resource)
		stateMap[resourceCode] = true
		namespaces[namespace] = true
	}

	resourcesForDeletion := []string{}

	for namespace := range namespaces {
		for _, kind := range apiResources {
			if _, ok := resourceTypesToIgnore[kind]; ok {
				continue
			}
			labels := map[string]interface{}{tankaEnvironmentLabel: environmentLabel}
			kindManifests, err := kube.GetByLabels(namespace, kind, labels)
			if err != nil {
				return nil, err
			}
			for _, m := range kindManifests {
				resourceCode := getResourceCode(namespace, m)

				if _, ok := stateMap[resourceCode]; !ok {
					resourcesForDeletion = append(resourcesForDeletion, resourceCode)

				}
			}
		}
	}

	return resourcesForDeletion, nil
}

func getEnvironmentLabel(environment string) string {
	if environment[len(environment)-1:] == "/" {
		return strings.ReplaceAll(environment[:len(environment)-1], "/", ".")
	}
	return strings.ReplaceAll(environment, "/", ".")
}

func getResourceCode(namespace string, m manifest.Manifest) string {
	kind := m.Kind()
	name := m.Metadata().Name()
	return namespace + "/" + kind + "/" + name
}
